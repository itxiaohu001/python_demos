import json

import requests


def write_to_elasticsearch():
    """将硬编码数据写入Elasticsearch"""

    # 硬编码的数据
    data = [
  {
    "hash": "24a6ec8ebf9c0867ed1c097f4a653b8d",
    "size": 163840,
    "threat": "Apt.Apt.1",
    "type": "file",
    "xm_hash": "61eb64895bde5551",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "af945758905e0615a10fe23070998b9b",
    "size": 118784,
    "threat": "Backdoor.Backdoor.2",
    "type": "file",
    "xm_hash": "370e386143f2c511",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "700e91a24f5cadd0cb7507f0d0077b26",
    "size": 118784,
    "threat": "Backdoor.Backdoor.3",
    "type": "file",
    "xm_hash": "d16a8bb59523d5c8",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "162ad6dbd50f3be407f49f65b938512a",
    "size": 122880,
    "threat": "Backdoor.Backdoor.4",
    "type": "file",
    "xm_hash": "86b3dc71c44383d1",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "69be938abe7f28615d933d5ce155057c",
    "size": 188416,
    "threat": "Backdoor.Backdoor.5",
    "type": "file",
    "xm_hash": "7b4efff4ebd86015",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "250b77dfbb1b666e95b3bcda082de287",
    "size": 122880,
    "threat": "Backdoor.Backdoor.6",
    "type": "file",
    "xm_hash": "315a4a96ce61ab13",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "32d5cca418b81e002bb3fdd8e4062bc9",
    "size": 467968,
    "threat": "Backdoor.Backdoor.7",
    "type": "file",
    "xm_hash": "57a071e71ce491a1",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "eefa6f98681d78b63f15d7e58934c6cc",
    "size": 674816,
    "threat": "Exploit.Exploit.8",
    "type": "file",
    "xm_hash": "3715b4089247c98f",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "04fb36199787f2e3e2135611a38321eb",
    "size": 346112,
    "threat": "Ransomware.Ransomware.9",
    "type": "file",
    "xm_hash": "00a030b8c5a50eff",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "8f90057ab244bd8b612cd09f566eac0c",
    "size": 721920,
    "threat": "Tool.Tool.10",
    "type": "file",
    "xm_hash": "9c9a78a190906f33",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  },
  {
    "hash": "5a559b6d223c79f3736dc52794636cfd",
    "size": 107520,
    "threat": "Trojan.Trojan.11",
    "type": "file",
    "xm_hash": "3f365523554ca9e9",
    "xm_update_time": "2025-11-20T16:17:07",
    "status": 2
  }
]

    # Elasticsearch配置
    ES_HOST = ""  # 修改为你的ES地址,例：10.x.x.x:9300
    INDEX_NAME = "malware_hash"  # 索引名称
    ES_USERNAME = ""  # 修改为你的用户名
    ES_PASSWORD = ""  # 修改为你的密码

    auth = (ES_USERNAME, ES_PASSWORD)

    # 检查ES连接
    def check_es_connection():
        try:
            response = requests.get(f"http://{ES_HOST}",auth=auth)
            if response.status_code == 200:
                print("✓ Elasticsearch连接成功")
                return True
            else:
                print(f"✗ Elasticsearch连接失败: {response.status_code}")
                return False
        except Exception as e:
            print(f"✗ 无法连接到Elasticsearch: {e}")
            print("请检查:")
            print("1. Elasticsearch服务是否启动")
            print("2. ES_HOST地址是否正确")
            print("3. 网络连接是否正常")
            return False

    # 创建索引（如果不存在）
    def create_index():
        index_url = f"http://{ES_HOST}/{INDEX_NAME}"

        # 检查索引是否存在
        response = requests.head(index_url,auth=auth)
        if response.status_code == 200:
            print(f"✓ 索引 {INDEX_NAME} 已存在")
            return True

        # 索引映射
        mapping = {
            "mappings": {
                "properties": {
                    "hash": {"type": "keyword"},
                    "size": {"type": "long"},
                    "threat": {"type": "keyword"},
                    "type": {"type": "keyword"},
                    "xm_hash": {"type": "keyword"},
                    "xm_update_time": {"type": "date", "format": "yyyy-MM-dd'T'HH:mm:ss"},
                    "status": {"type": "integer"}
                }
            }
        }

        response = requests.put(index_url, json=mapping,auth=auth)
        if response.status_code == 200:
            print(f"✓ 索引 {INDEX_NAME} 创建成功")
            return True
        else:
            print(f"✗ 索引创建失败: {response.text}")
            return False

    # 批量插入数据
    def bulk_insert():
        bulk_data = []

        # 准备批量操作数据
        for i, doc in enumerate(data, 1):
            # 操作描述
            bulk_data.append({
                "index": {
                    "_index": INDEX_NAME,
                    "_id": doc['hash']  # 使用序号作为文档ID
                }
            })
            # 文档数据
            bulk_data.append(doc)

        # 转换为批量API要求的格式
        bulk_body = "\n".join([json.dumps(line) for line in bulk_data]) + "\n"

        # 发送批量请求
        url = f"http://{ES_HOST}/_bulk"
        headers = {"Content-Type": "application/json"}

        try:
            response = requests.post(url, data=bulk_body, headers=headers, timeout=30,auth=auth)

            if response.status_code == 200:
                result = response.json()

                if not result.get("errors"):
                    print(f"✓ 成功插入 {len(data)} 条文档")

                    # 显示插入统计
                    if "items" in result:
                        successful = len([item for item in result["items"] if item["index"]["status"] == 201])
                        print(f"✓ 成功: {successful} 条, 失败: {len(data) - successful} 条")

                    return True
                else:
                    print("✗ 批量插入出现错误:")
                    # 显示错误详情
                    errors = []
                    for item in result.get("items", []):
                        if "error" in item.get("index", {}):
                            errors.append(item["index"]["error"])

                    if errors:
                        print("错误详情:")
                        for error in errors[:3]:  # 只显示前3个错误
                            print(f"  - {error}")
                    return False
            else:
                print(f"✗ 插入失败，HTTP状态码: {response.status_code}")
                print(f"错误信息: {response.text}")
                return False

        except requests.exceptions.Timeout:
            print("✗ 请求超时，请检查Elasticsearch性能或网络连接")
            return False
        except Exception as e:
            print(f"✗ 请求异常: {e}")
            return False

    # 验证数据插入
    def verify_data():
        try:
            # 查询文档数量
            count_url = f"http://{ES_HOST}/{INDEX_NAME}/_count"
            response = requests.get(count_url,auth=auth)

            if response.status_code == 200:
                count_result = response.json()
                doc_count = count_result.get("count", 0)
                print(f"✓ 索引中文档数量: {doc_count} 条")

                if doc_count >= len(data):
                    print("✓ 数据验证通过")
                else:
                    print(f"x 文档数量不匹配，期望: {len(data)}，实际: {doc_count}")

                return doc_count
            else:
                print("✗ 无法验证数据数量")
                return 0

        except Exception as e:
            print(f"✗ 验证数据时出错: {e}")
            return 0

    # 主执行流程
    print("开始将数据写入Elasticsearch...")
    print("=" * 50)

    # 1. 检查连接
    if not check_es_connection():
        return False

    # 2. 创建索引
    if not create_index():
        return False

    # 3. 显示数据统计
    print(f"准备插入 {len(data)} 条威胁数据:")
    threat_stats = {}
    for doc in data:
        threat_type = doc["threat"].split(".")[0] if "." in doc["threat"] else doc["threat"]
        threat_stats[threat_type] = threat_stats.get(threat_type, 0) + 1

    for threat_type, count in threat_stats.items():
        print(f"   - {threat_type}: {count} 条")

    # 4. 批量插入数据
    print("\n开始批量插入数据...")
    if not bulk_insert():
        return False

    # 5. 验证数据
    print("\n验证数据插入结果...")
    verify_data()

    print("=" * 50)
    print("✓ 数据写入完成！")

    return True


if __name__ == "__main__":
    # 执行写入操作
    success = write_to_elasticsearch()

    if not success:
        print("\nx 数据写入失败，请检查上述错误信息")
        exit(1)
    else:
        print("\n✓ 脚本执行成功！")