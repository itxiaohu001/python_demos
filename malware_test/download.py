import os
import json
import requests
import zipfile
import hashlib
from urllib.parse import unquote
import time

# 恶意软件列表
malware_list = [
    "All.ElectroRAT",
    "AndroRat_6Dec2013",
    "Android.PegasusB",
    "Android.Skygofree",
    "Android.Spy.49_iBanking_Feb2014",
    "Android.VikingHorde",
    "AntiExe.A",
    "Artemis",
    "BAT.Drop",
    "BAT.Pot.A",
    "BAT.Skul",
    "Backdoor.MSIL.Tyupkin",
    "BlackEnergy2.1",
    "Brain.A",
    "Careto_Feb2014",
    "Cascade.1701.W",
    "Catapillar.E",
    "Civil_War.282",
    "Coll.CozyBear",
    "Coll.DarkHydrus",
    "CryptoLocker_10Sep2013",
    "CryptoLocker_20Nov2013",
    "CryptoLocker_22Jan2014",
    "DOS.Yesmile",
    "Dino",
    "Dropper.Taleret",
    "Duqu2",
    "Dyre",
    "EarthKrahang_20240404",
    "EquationGroup.DoubleFantasy",
    "EquationGroup.EquationDrug",
    "EquationGroup.EquationLaser",
    "EquationGroup.Fanny",
    "EquationGroup.GROK",
    "EquationGroup.GrayFish",
    "EquationGroup.TripleFantasy",
    "EquationGroup",
    "FancyBear.GermanParliament",
    "Form.A",
    "Friday_the_13th.408",
    "Friday_the_13th.416.A",
    "Friday_the_13th.416.B",
    "Friday_the_13th.540.A",
    "Green_Caterpillar.1575.A",
    "INTC.A",
    "IllusionBot_May2007",
    "JS.JScript.A",
    "JS.Lame",
    "Jumper.B",
    "Junkie",
    "KRBanker",
    "Kampana.A",
    "Kelihos",
    "Keylogger.Ardamax",
    "Linux.Chapros.A",
    "Linux.Encoder.1",
    "Linux.Mirai.B",
    "Linux.Snoopy.A",
    "Linux.Snoopy.B",
    "Linux.Snoopy.C",
    "Linux.Wirenet",
    "Michelangelo",
    "MustangPanda_20230922",
    "NOBELIUM",
    "NYB.B",
    "Net-Worm.Win32.Kido",
    "Neurevt.1.7.0.1",
    "Nitlove",
    "Nivdort",
    "OSX.Backdoor.iWorm",
    "OSX.HellRaiser",
    "OSX.JacksBot",
    "OSX.Lazarus",
    "OSX.MacSecurity",
    "OSX.OceanLotus",
    "OSX.Wirenet",
    "OSX.XAgent",
    "Parity_Boot.B",
    "Phoenix.2000",
    "PlugX",
    "PotaoExpress",
    "Poweliks",
    "Proteus",
    "Quax.A",
    "Raccoon.Stealer.v2",
    "Ransomware.Cerber",
    "Ransomware.Cryptowall",
    "Ransomware.Hive",
    "Ransomware.Jigsaw",
    "Ransomware.Locky",
    "Ransomware.Mamba",
    "Ransomware.Matsnu",
    "Ransomware.Petrwrap",
    "Ransomware.Petya",
    "Ransomware.Radamant",
    "Ransomware.RedBoot",
    "Ransomware.Rex",
    "Ransomware.Satana",
    "Ransomware.TeslaCrypt",
    "Ransomware.Thanos",
    "Ransomware.Unnamed_0",
    "Ransomware.Vipasana",
    "Ransomware.WannaCry",
    "Ransomware.WannaCry_Plus",
    "Ransomware.XData",
    "Rombertik",
    "Rustock",
    "Sampo.A",
    "Shamoon",
    "SheHas.A",
    "SillyC.160.B",
    "Skywiper-A.Flame",
    "Slow_Format.705",
    "Somoto",
    "SpyEye",
    "Surtr",
    "SymbOS.Lasco",
    "Telefonica.3784",
    "Trivial.881",
    "Trivial.Html.883",
    "Trivial.LSD",
    "Trojan.AlienSpy",
    "Trojan.Asprox",
    "Trojan.Bladabindi",
    "Trojan.Destover-SonySigned",
    "Trojan.Dropper.Gen",
    "Trojan.Kovter",
    "Trojan.Loadmoney",
    "Trojan.NSIS.Win32",
    "Trojan.Ransom.Hells",
    "Trojan.Ransom.Petya",
    "Trojan.Regin",
    "Trojan.Shylock.Skype",
    "Trojan.Sinowal",
    "Trojan.Stabuniq",
    "Trojan.Tapaoux",
    "Trojan.Win32.Bechiro.BCD",
    "TrojanWin32.Duqu.Stuxnet",
    "VBS.Carnival",
    "VBS.Hopper",
    "VBS.LoveLetter",
    "VBS.NewLove.A",
    "VBS.NoMercy.B",
    "VBS.NoWarning.A",
    "VBS.Redinal",
    "VBS.RunScript",
    "VBS.Vquest.ow",
    "Variant.Kazy",
    "VolatileCedar.Explosion",
    "W32.Beagle",
    "W32.CodeRed.Worm.C",
    "W32.Duni.A",
    "W32.Elkern.B",
    "W32.HLLP.Hantaner.A",
    "W32.Hybris.Worm.B",
    "W32.Klez.E",
    "W32.Klez.H",
    "W32.MyDoom.A",
    "W32.Mytob_EJ",
    "W32.NetSky",
    "W32.Nimda.A",
    "W32.Nimda.E",
    "W32.Slammer",
    "W32.Swen",
    "W97M.Class.AU",
    "W97M.Melissa.A",
    "W97M.Pri.A",
    "W97M.Pri.AB",
    "WM.Alliance.A",
    "WM.Cap.A",
    "WM.Concept.A",
    "WM.Concept.S",
    "WM.Minimal.AB",
    "WM.NJ_WMVCK2_T",
    "WM.Npad.A",
    "WMIGhost",
    "Waski.Upatre",
    "Win32.APT28.SekoiaRootkit",
    "Win32.APT32.Windshield",
    "Win32.AgentTesla",
    "Win32.Alina.3.4.B",
    "Win32.Avatar",
    "Win32.BUMBLEBEE_0.1",
    "Win32.BigBang",
    "Win32.Boaxxe.BB",
    "Win32.Cainxpii",
    "Win32.Caphaw.Shylock",
    "Win32.Carberp",
    "Win32.Cridex",
    "Win32.Cutwail",
    "Win32.DarkTequila",
    "Win32.Emotet",
    "Win32.EternalRocks",
    "Win32.FASTCash",
    "Win32.FamousSparrow",
    "Win32.Fareit",
    "Win32.GhostSec",
    "Win32.GravityRat",
    "Win32.GreenBug",
    "Win32.Hupigon",
    "Win32.Infostealer.Dexter",
    "Win32.Invicea_Tunnel",
    "Win32.Ixeshe",
    "Win32.Jerusalem",
    "Win32.KerrDown",
    "Win32.KeyPass",
    "Win32.Lephic",
    "Win32.LuckyCat",
    "Win32.MyLobot",
    "Win32.Narilam",
    "Win32.OnionDuke.B",
    "Win32.Pay2Key.B",
    "Win32.Powerstats",
    "Win32.RedDelta",
    "Win32.Reveton",
    "Win32.Sality",
    "Win32.ShadowHammer",
    "Win32.Sofacy.A",
    "Win32.SofacyCarberp",
    "Win32.StrongPity",
    "Win32.Stuxnet.A.Duqu-C-Media",
    "Win32.Stuxnet.B.Duqu-Realtek",
    "Win32.Taleret",
    "Win32.TransparentTribe.B",
    "Win32.Triton",
    "Win32.Turla.V1",
    "Win32.Turla",
    "Win32.Unclassified",
    "Win32.Unknown_SpectreMeltdown",
    "Win32.Unnamed_SpecMelt",
    "Win32.VBS.APT34Dropper",
    "Win32.ValeforBeta",
    "Win32.Vobfus",
    "Win32.WannaPeace",
    "Win32.XAgent",
    "Win32.ZeroCleare",
    "Win32.ZeusVM",
    "Win32.Zurgop",
    "Win32Dircrypt.Trojan.Ransom.ABZ",
    "Win64.NukeSped",
    "Win64.Trojan.GreenBug",
    "WinX.HiddenCobra.Supply",
    "WinX.OperationDianxun",
    "WinX.SUNBURST",
    "WinX.SignSight",
    "Wiper.BEEP.E",
    "Wiper.SAPP.IC",
    "Wiper.WIPE32.P",
    "X97M.Sugar.A",
    "X97M.Sugar_Poppy.II",
    "Yankee_Doodle.2881.A",
    "Yankee_Doodle.2997",
    "Yankee_Login.3052",
    "Yaunch.2537",
    "Yeke.1204",
    "ZeroAccess",
    "ZeroLocker",
    "ZeusBankingVersion_26Nov2013",
    "ZeusGameover_Feb2014",
    "Zherkov.1958",
    "Zherkov.2970",
    "njRAT-v0.6.4"
]


def download_file(url, local_filename, max_retries=3):
    """下载文件，支持重试机制"""
    for attempt in range(max_retries):
        try:
            response = requests.get(url, stream=True, timeout=30)
            response.raise_for_status()

            with open(local_filename, 'wb') as f:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        f.write(chunk)
            return True
        except Exception as e:
            print(f"下载失败 (尝试 {attempt + 1}/{max_retries}): {e}")
            if attempt < max_retries - 1:
                time.sleep(2)

    return False


def get_password(password_url):
    """获取解压密码"""
    try:
        response = requests.get(password_url, timeout=10)
        if response.status_code == 200:
            return response.text.strip()
        else:
            # 如果密码文件不存在，尝试常见密码
            common_passwords = ["infected", "virus", "malware", "theZoo"]
            return common_passwords[0]
    except:
        return "infected"  # 默认密码


def calculate_md5(file_path):
    """计算文件的MD5哈希值"""
    try:
        hash_md5 = hashlib.md5()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    except Exception as e:
        print(f"计算MD5失败: {e}")
        return None


def extract_zip(zip_path, extract_to, password=None):
    """解压ZIP文件"""
    try:
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            if password:
                zip_ref.setpassword(password.encode())
            zip_ref.extractall(extract_to)
            return True
    except Exception as e:
        print(f"解压失败: {e}")
        return False


def process_malware_sample(malware_name, base_dir="malware_samples"):
    """处理单个恶意软件样本"""
    print(f"正在处理: {malware_name}")

    # 创建目录结构
    malware_dir = os.path.join(base_dir, malware_name)
    os.makedirs(malware_dir, exist_ok=True)

    # 构建URL
    base_url = "https://raw.githubusercontent.com/ytisf/theZoo/master/malware/Binaries"
    zip_url = f"{base_url}/{malware_name}/{malware_name}.zip"
    password_url = f"{base_url}/{malware_name}/{malware_name}.pass"

    # 本地文件路径
    zip_path = os.path.join(malware_dir, f"{malware_name}.zip")
    extract_path = os.path.join(malware_dir, "extracted")

    result = {
        "name": malware_name,
        "zip_url": zip_url,
        "password_url": password_url,
        "download_success": False,
        "extraction_success": False,
        "md5_hash": None,
        "error": None
    }

    try:
        # 1. 下载ZIP文件
        print(f"  下载ZIP文件...")
        if not download_file(zip_url, zip_path):
            result["error"] = "下载ZIP文件失败"
            return result

        result["download_success"] = True

        # 2. 获取密码
        print(f"  获取解压密码...")
        password = get_password(password_url)

        # 3. 解压文件
        print(f"  解压文件...")
        os.makedirs(extract_path, exist_ok=True)

        if not extract_zip(zip_path, extract_path, password):
            # 尝试无密码解压
            if not extract_zip(zip_path, extract_path):
                result["error"] = "解压失败"
                return result

        result["extraction_success"] = True

        # 4. 计算解压文件的MD5
        print(f"  计算MD5...")
        extracted_files = []
        for root, dirs, files in os.walk(extract_path):
            for file in files:
                file_path = os.path.join(root, file)
                if os.path.isfile(file_path):
                    md5 = calculate_md5(file_path)
                    if md5:
                        extracted_files.append({
                            "filename": file,
                            "path": file_path,
                            "md5": md5
                        })

        if extracted_files:
            result["extracted_files"] = extracted_files
            # 如果有多个文件，取第一个文件的MD5作为主要MD5
            result["md5_hash"] = extracted_files[0]["md5"]

        print(f"  完成: {malware_name}")

    except Exception as e:
        result["error"] = str(e)
        print(f"  处理失败: {e}")

    return result


def main():
    # 创建输出目录
    os.makedirs("malware_samples", exist_ok=True)

    results = []
    successful_downloads = 0
    successful_extractions = 0

    print(f"开始处理 {len(malware_list)} 个恶意软件样本...")
    print("=" * 50)

    for i, malware_name in enumerate(malware_list, 1):
        print(f"[{i}/{len(malware_list)}] ", end="")

        result = process_malware_sample(malware_name)
        results.append(result)

        if result["download_success"]:
            successful_downloads += 1
        if result["extraction_success"]:
            successful_extractions += 1

        # 添加延迟避免请求过快
        time.sleep(1)

    # 保存结果到JSON文件
    output_file = "malware_analysis_results.json"
    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump({
            "summary": {
                "total_samples": len(malware_list),
                "successful_downloads": successful_downloads,
                "successful_extractions": successful_extractions,
                "processing_date": time.strftime("%Y-%m-%d %H:%M:%S")
            },
            "results": results
        }, f, indent=2, ensure_ascii=False)

    print("=" * 50)
    print(f"处理完成!")
    print(f"总样本数: {len(malware_list)}")
    print(f"成功下载: {successful_downloads}")
    print(f"成功解压: {successful_extractions}")
    print(f"结果已保存到: {output_file}")


if __name__ == "__main__":
    # 安装依赖检查
    try:
        import requests
    except ImportError:
        print("请先安装requests库: pip install requests")
        exit(1)

    main()