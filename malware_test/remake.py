#coding:utf-8
import copy
import datetime
import json

#pip install xxhash
import xxhash
import traceback
from loguru import logger

def to_xx_hash(b):
	xx_hash = ''
	try:
		xx_hash = xxhash.xxh64_hexdigest(b)
		#xx_hash = xxhash.xxh3_128_hexdigest(b)
	except:
		logger.error(f'[lib_common->to_xx_hash] {traceback.format_exc()}')
	return xx_hash

#去掉float数字末尾的0，因为es会这样处理，为了保持一致
def delete_extra_zero(n):
	try:
		if isinstance(n, float):
			n = str(n).rstrip('0')
			n = int(n.rstrip('.')) if n.endswith('.') else float(n)
	except:
		logger.error(f'[lib_common->delete_extra_zero] {traceback.format_exc()}')
	return n

#dls支持字典、列表、字符串，其他类型会强制转为字符串进行计算，0、None、False等false的值统一转为空字符串
def sign(dls, extra_excludes=None):
	a_hash = ''
	try:
		if dls:
			_dls = copy.deepcopy(dls)
			if isinstance(dls,dict):
				#内置排除字段
				excludes = ['@version', 'xm_update_time', 'xm_hash', 'manual_verify', 'status',
				'vul_tag', 'vul_source', 'vul_version_detail_v2']
				if isinstance(extra_excludes,list):
					excludes.extend(extra_excludes)
				for e in excludes:
					_dls.pop(e,None)

			def get_sorted_string_from_dict(x:dict):
				s = ''
				#字典的key转为字符串
				sd = {}
				for k,v in x.items():
					sd[str(k)] = delete_extra_zero(v)
				x = sd
				#对字典的key进行排序
				sk = sorted(x.keys())
				for k in sk:
					if isinstance(x[k],dict):
						s = f'{s}{k}{get_sorted_string_from_dict(x[k])}'
					elif isinstance(x[k],list):
						s = f'{s}{k}{get_sorted_string_from_list(x[k])}'
					elif not x[k]:
						s = f'{s}{k}'
					else:
						s = f'{s}{k}{x[k]}'
				return s

			def get_sorted_string_from_list(x:list):
				sx = copy.deepcopy(x)
				for i,v in enumerate(x):
					if isinstance(v,dict):
						sx[i] = get_sorted_string_from_dict(v)
					elif isinstance(v,list):
						sx[i] = get_sorted_string_from_list(v)
					elif not v:
						sx[i] = ''
					else:
						sx[i] = str(delete_extra_zero(v))
				sx.sort()
				s = ''.join(sx)
				return s

			def get_sorted_string(x):
				s = ''
				if isinstance(x,dict):
					s = f'{s}{get_sorted_string_from_dict(x)}'
				elif isinstance(x,list):
					s = f'{s}{get_sorted_string_from_list(x)}'
				else:
					if x:
						s = str(delete_extra_zero(x))
				return s

			# #强制以字符串排序 里面的列表、字典顺序有变化而值其实没变那hash也会变，期望hash应该是一样的
			# s = ''
			# sorted_list = sorted(d.items(), key=lambda x:x[0])
			# for v in sorted_list:
			# 	s = f'{s}{v[0]}{v[1]}'
			#递归解析排序 写的代码可能有问题
			s = get_sorted_string(_dls)
			#不对空字串进行计算
			#空字符串md5: d41d8cd98f00b204e9800998ecf8427e，xx_hash: ef46db3751d8e999
			if s:
				a_hash = to_xx_hash(s)
	except:
		logger.error(f'[lib_common->sign] {traceback.format_exc()}')
	return a_hash

# host = "http://10.1.2.202:9300"
# username = "xmes"
# password = "XMPWD_LrAn2eCe_sca"
# # 初始化 Elasticsearch 客户端
# ES = Elasticsearch(hosts=host, http_auth=(username, password), timeout=120)
#
# # 设置账号名密码
# # 索引名称
# INDEX_NAME = "malware_hash"
#
# def into_es(data):
# 	data['xm_hash'] = sign(data)
# 	data['xm_update_time'] = datetime.now().strftime('%Y-%m-%dT%H:%M:%S')
# 	data['status'] = 2
# 	md5 = data['hash']
# 	res = ES.index(index=INDEX_NAME, doc_type='_doc', id=md5, body=data)
# 	print(res)

def load_json_data(file_path):
	"""从JSON文件加载数据"""
	try:
		with open(file_path, 'r', encoding='utf-8') as f:
			data = json.load(f)
		return data
	except FileNotFoundError:
		print(f"文件 {file_path} 不存在")
		return None
	except json.JSONDecodeError as e:
		print(f"JSON解析错误: {e}")
		return None
	except Exception as e:
		print(f"读取文件时出错: {e}")
		return None


if __name__ == "__main__":
	json_file = "file_analysis_results.json"
	data = load_json_data(json_file)

	if data:
		print(f"成功加载 {len(data)} 条记录")
		for i, item in enumerate(data):
			item['xm_hash'] = sign(data)
			item['xm_update_time'] = datetime.datetime.now().strftime('%Y-%m-%dT%H:%M:%S')
			item['status'] = 2
	with open('file_analysis_results_with_timestamp.json', 'w', encoding='utf-8') as f:
		json.dump(data, f, indent=2, ensure_ascii=False)